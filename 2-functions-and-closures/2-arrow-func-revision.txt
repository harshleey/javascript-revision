âœ… Good Use Cases:
javascript
// 1. Callbacks and array methods
const numbers = [1, 2, 3];
const doubled = numbers.map(n => n * 2);

// 2. Promises and async code
fetch(url)
    .then(response => response.json())
    .then(data => console.log(data));

// 3. Short, simple functions
const isEven = n => n % 2 === 0;

// 4. Preserving this in callbacks
class Button {
    constructor() {
        this.clicks = 0;
        this.element.addEventListener('click', () => {
            this.clicks++; // âœ… this refers to Button instance
        });
    }
}

âŒ Avoid Arrow Functions For:
javascript
// 1. Object methods
const obj = {
    name: "Bad",
    // âŒ Don't do this:
    badMethod: () => console.log(this.name), // undefined
    
    // âœ… Do this instead:
    goodMethod: function() { console.log(this.name); }
};

// 2. Constructor functions
// âŒ const Person = (name) => { this.name = name; }
// âœ… function Person(name) { this.name = name; }

// 3. Functions using arguments object
// âŒ const sum = () => { console.log(arguments); }
// âœ… function sum() { console.log(arguments); }
// âœ… const sum = (...args) => { console.log(args); }

ğŸ“‹ Quick Reference Card
javascript
// âœ… Implicit return (single expression)
const square = x => x * x;

// âœ… Explicit return (multiple statements)
const complex = (x, y) => {
    const result = x + y;
    return result * 2;
};

// âœ… Returning objects (wrap in parentheses)
const makePoint = (x, y) => ({ x, y });

// âœ… Single parameter (no parentheses needed)
const greet = name => `Hello ${name}`;

// âœ… No parameters (empty parentheses)
const random = () => Math.random();

// âŒ No arguments object
// âŒ No own this binding  
// âŒ Can't use as constructor
// âŒ Can't use yield in generator arrows